function createGDS(r,steppedProfile,optic)
% designed to take the stepped phase profile generated by findModProfile
% and convert it to a GDS file 

% To do this, we're using the Raith_GDSII software library from
% https://github.com/nrc-cnrc/Raith_GDSII.git


addpath('Raith_GDSII');


% Variables
numLayers       = optic.numLayers;
numV            = 1000; %number of vertices
name            = optic.type;


% Our masks, for both the axilens and axicon are made from a series of
% concentric circles and so should be fairly simple to model

% Step 1: Break stepped profile into indiviudal masks
etchDepth = max(steppedProfile)/(numLayers-1);  % how deep is each etch
disp(sprintf('EtchDepth = %f um',etchDepth));
masks = {};                                     
for i = 1:numLayers
    tmpProfile = steppedProfile;                    % set up a temporary mask
    tmpProfile(tmpProfile < (i-.1)*etchDepth) = 0;  % everything smaller than etch layer must be etched - mask =0
    tmpProfile(tmpProfile >= (i-.1)*etchDepth) = 1; % everything else must remain - mask=1
    masks{i} = tmpProfile;                          % Move temporary mask to the mask array
end

% We now have a structure of masks - lets step through each mask and create
% a set of raith_elements for it
% The raith_element we are using is that of a circle

ctr = 0;
for i = 1:numLayers
    
    % first calculate the layer parameters
    layerParams = findLayerParams(r,masks{i});
    numElements = length(layerParams);

    for j = 1:numElements
        [xArr,yArr] = polygonRing(layerParams{j}.r , layerParams{j}.w, numV);
        E(ctr+1) = Raith_element('polygon',i-1 , [xArr ; yArr], 1.3);
        axis equal;
        E(ctr+1).plot;
        ctr = ctr+1;
    end
    
    


end


    S=Raith_structure(name,E);
    clf;
    axis equal;
    S.plot;
    L=Raith_library(name,S);
    L.writegds;
   
end